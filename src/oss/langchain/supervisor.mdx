---
title: Build a supervisor agent
sidebarTitle: Supervisor agent
---

The **supervisor pattern** is a multi-agent architecture where a central supervisor agent coordinates specialized worker agents. This approach excels when tasks require different types of expertise. Rather than building one complex agent that struggles with tool selection across domains, you create focused specialists coordinated by a supervisor who understands the overall workflow.

In this tutorial, you'll build a personal assistant system that demonstrates these benefits through a realistic workflow. Your system will coordinate two specialists with fundamentally different responsibilities:

- A **calendar agent** that handles scheduling, availability checking, and event management. Calendar agents work with dates and time formats.
- An **email agent** that manages communication, drafts messages, and sends notifications. Email agents work with recipients and message composition.

You'll learn to build this system step by step, understanding why each layer exists and how they work together to handle complex user requests.

## Setup

First, install the required packages and configure your API keys. You'll need LangChain for building the multi-agent system and Anthropic for the language model.

```bash
pip install --pre -U "langchain[anthropic]"
```

```python
import getpass
import os

def _set_if_undefined(var: str):
    if not os.environ.get(var):
        os.environ[var] = getpass.getpass(f"Please provide your {var}")

_set_if_undefined("ANTHROPIC_API_KEY")
```

Optionally, set up LangSmith for debugging:

```python
_set_if_undefined("LANGSMITH_API_KEY")
os.environ["LANGSMITH_TRACING"] = "true"
```

## Why use a supervisor?

A single agent with many tools struggles to make good routing decisions. Consider an agent with direct access to all calendar and email APIs—it must choose from many similar tools, understand exact formats for each API, and handle multiple domains simultaneously. This leads to poor tool selection and difficult maintenance.

The supervisor pattern solves this by creating layers of abstraction. A supervisor routes to high-level capabilities like "schedule event" or "manage email", while specialized sub-agents handle the complexity of translating natural language to rigid API calls. This separation improves both routing quality and maintainability.

## 1. Define low-level API tools

Start by defining the rigid API tools that require structured inputs. In real applications, these would call actual APIs (Google Calendar, SendGrid, etc.). For this tutorial, you'll use stubs to demonstrate the pattern.

The key insight here is that these tools have **strict requirements** that make them difficult for LLMs to use directly. This motivates the need for sub-agents that act as bridges between natural language and rigid APIs.

```python
from langchain_core.tools import tool

@tool
def create_calendar_event(
    title: str,
    start_time: str,  # ISO format: "2024-01-15T14:00:00"
    end_time: str,    # ISO format: "2024-01-15T15:00:00"
    attendees: list[str],  # email addresses
    location: str = ""
) -> str:
    """Create a calendar event. Requires exact ISO datetime format."""
    # Stub: In practice, this would call Google Calendar API, Outlook API, etc.
    return f"Event created: {title} from {start_time} to {end_time} with {len(attendees)} attendees"


@tool
def send_email(
    to: list[str],      # email addresses
    subject: str,
    body: str,
    cc: list[str] = []
) -> str:
    """Send an email via email API. Requires properly formatted addresses."""
    # Stub: In practice, this would call SendGrid, Gmail API, etc.
    return f"Email sent to {', '.join(to)} - Subject: {subject}"


@tool
def get_available_time_slots(
    attendees: list[str],
    date: str,  # ISO format: "2024-01-15"
    duration_minutes: int
) -> list[str]:
    """Check calendar availability for given attendees on a specific date."""
    # Stub: In practice, this would query calendar APIs
    return ["09:00", "14:00", "16:00"]
```

These tools require exact ISO format dates, properly formatted email addresses, and all required parameters. Rather than burden a single LLM with parsing natural language, choosing tools, and understanding formats simultaneously, you'll create specialized sub-agents that handle each domain.

## 2. Create specialized sub-agents

Now create sub-agents that bridge natural language and the rigid APIs. Each sub-agent is an expert in its domain with focused tools and a specialized prompt. This specialization allows the agent to excel at its specific task rather than being a generalist.

### Create a calendar agent

The calendar agent understands natural language scheduling requests and translates them into precise API calls. It handles date parsing, availability checking, and event creation.

```python
from langchain_anthropic import ChatAnthropic
from langgraph.prebuilt import create_react_agent

calendar_agent = create_react_agent(
    ChatAnthropic(model="claude-3-5-sonnet-20241022"),
    tools=[create_calendar_event, get_available_time_slots],
    state_modifier=(
        "You are a calendar scheduling assistant. "
        "Parse natural language scheduling requests (e.g., 'next Tuesday at 2pm') "
        "into proper ISO datetime formats. "
        "Use get_available_time_slots to check availability when needed. "
        "Use create_calendar_event to schedule events. "
        "Always confirm what was scheduled in your final response."
    )
)
```

Test the calendar agent to see how it handles natural language scheduling:

```python
result = calendar_agent.invoke({
    "messages": [{"role": "user", "content": "Schedule a team meeting next Tuesday at 2pm for 1 hour"}]
})

print(result["messages"][-1].content)
```

**Output:**
```
I'll schedule that team meeting for you.

[Tool calls showing date parsing and event creation]

I've scheduled your team meeting for next Tuesday, January 16th at 2:00 PM for 1 hour (ending at 3:00 PM).
```

The agent parses "next Tuesday at 2pm" into ISO format ("2024-01-16T14:00:00"), calculates the end time, calls `create_calendar_event`, and returns a natural language confirmation.

### Create an email agent

The email agent handles message composition and sending. It focuses on extracting recipient information, crafting appropriate subject lines and body text, and managing email communication.

```python
email_agent = create_react_agent(
    ChatAnthropic(model="claude-3-5-sonnet-20241022"),
    tools=[send_email],
    state_modifier=(
        "You are an email assistant. "
        "Compose professional emails based on natural language requests. "
        "Extract recipient information and craft appropriate subject lines and body text. "
        "Use send_email to send the message. "
        "Always confirm what was sent in your final response."
    )
)
```

Test the email agent with a natural language request:

```python
result = email_agent.invoke({
    "messages": [{"role": "user", "content": "Send the design team a reminder about reviewing the new mockups"}]
})

print(result["messages"][-1].content)
```

**Output:**
```
I'll send that reminder for you.

[Tool calls showing email composition]

I've sent an email to the design team with the subject "Reminder: Review New Mockups" asking them to review the latest mockups at their earliest convenience.
```

The agent infers the recipient from the informal request, crafts a professional subject line and body, calls `send_email`, and returns a confirmation. Each sub-agent has a narrow focus with domain-specific tools and prompts, allowing it to excel at its specific task.

## 3. Wrap sub-agents as tools

Now wrap each sub-agent as a tool that the supervisor can invoke. This is the key architectural step that creates the layered system. The supervisor will see high-level tools like "schedule_event", not low-level tools like "create_calendar_event".

```python
@tool(
    name="schedule_event",
    description=(
        "Schedule calendar events using natural language. "
        "Use this when the user wants to create, modify, or check calendar appointments. "
        "Handles date/time parsing, availability checking, and event creation. "
        "Input: Natural language scheduling request (e.g., 'meeting with design team next Tuesday at 2pm')"
    )
)
def schedule_event_tool(request: str) -> str:
    """Schedule a calendar event using natural language."""
    result = calendar_agent.invoke({
        "messages": [{"role": "user", "content": request}]
    })
    return result["messages"][-1].content


@tool(
    name="manage_email",
    description=(
        "Send emails using natural language. "
        "Use this when the user wants to send notifications, reminders, or any email communication. "
        "Handles recipient extraction, subject generation, and email composition. "
        "Input: Natural language email request (e.g., 'send them a reminder about the meeting')"
    )
)
def manage_email_tool(request: str) -> str:
    """Send or draft an email using natural language."""
    result = email_agent.invoke({
        "messages": [{"role": "user", "content": request}]
    })
    return result["messages"][-1].content
```

The tool descriptions help the supervisor decide when to use each tool, so make them clear and specific. The tools accept natural language strings rather than structured parameters, allowing sub-agents to handle parsing complexity. Return only the sub-agent's final response—the supervisor doesn't need to see intermediate reasoning or tool calls.

## 4. Create the supervisor agent

Now create the supervisor that orchestrates the sub-agents. The supervisor only sees high-level tools and makes routing decisions at the domain level, not the individual API level.

```python
supervisor_agent = create_react_agent(
    ChatAnthropic(model="claude-3-5-sonnet-20241022"),
    tools=[schedule_event_tool, manage_email_tool],
    state_modifier=(
        "You are a helpful personal assistant. "
        "You can schedule calendar events and send emails. "
        "Break down user requests into appropriate tool calls and coordinate the results. "
        "When a request involves multiple actions, use multiple tools in sequence."
    )
)
```

The supervisor operates at a higher level of abstraction. It knows about high-level capabilities and how to coordinate them, but doesn't need to understand ISO datetime formats, email address formats, or other low-level API details. This separation of concerns is the key benefit of the supervisor pattern.

## 5. Use the supervisor

Now test your complete system with complex requests that require coordination across multiple domains. This demonstrates the real power of the supervisor pattern.

### Example 1: Simple single-domain request

```python
result = supervisor_agent.invoke({
    "messages": [{"role": "user", "content": "Schedule a team standup for tomorrow at 9am"}]
})

print(result["messages"][-1].content)
```

**Output:**
```
I've scheduled your team standup for tomorrow, January 15th at 9:00 AM.
```

The supervisor identifies this as a calendar task, calls `schedule_event_tool`, and the calendar agent handles date parsing and event creation.

### Example 2: Complex multi-domain request

```python
result = supervisor_agent.invoke({
    "messages": [{
        "role": "user",
        "content": (
            "Schedule a meeting with the design team next Tuesday at 2pm for 1 hour, "
            "and send them an email reminder about reviewing the new mockups."
        )
    }]
})

print(result["messages"][-1].content)
```

**Output:**
```
I've completed both tasks for you:

1. Scheduled a meeting with the design team for next Tuesday, January 16th at 2:00 PM for 1 hour (ending at 3:00 PM).

2. Sent an email to the design team reminding them to review the new mockups, with a reference to the upcoming meeting.
```

The supervisor recognizes this requires both calendar and email actions, calls `schedule_event_tool` for the meeting, then calls `manage_email_tool` for the reminder. Each sub-agent completes its task, and the supervisor synthesizes both results into a coherent response.

## Complete working example

Here's everything together in a runnable script:

<Expandable title="View complete code" defaultOpen={false}>

```python
"""
Personal Assistant Supervisor Example

This example demonstrates the tool calling pattern for multi-agent systems.
A supervisor agent coordinates specialized sub-agents (calendar and email)
that are wrapped as tools.
"""

from langchain_core.tools import tool
from langchain_anthropic import ChatAnthropic
from langgraph.prebuilt import create_react_agent

# ============================================================================
# Step 1: Define low-level API tools (stubbed)
# ============================================================================

@tool
def create_calendar_event(
    title: str,
    start_time: str,  # ISO format: "2024-01-15T14:00:00"
    end_time: str,    # ISO format: "2024-01-15T15:00:00"
    attendees: list[str],  # email addresses
    location: str = ""
) -> str:
    """Create a calendar event. Requires exact ISO datetime format."""
    return f"Event created: {title} from {start_time} to {end_time} with {len(attendees)} attendees"


@tool
def send_email(
    to: list[str],      # email addresses
    subject: str,
    body: str,
    cc: list[str] = []
) -> str:
    """Send an email via email API. Requires properly formatted addresses."""
    return f"Email sent to {', '.join(to)} - Subject: {subject}"


@tool
def get_available_time_slots(
    attendees: list[str],
    date: str,  # ISO format: "2024-01-15"
    duration_minutes: int
) -> list[str]:
    """Check calendar availability for given attendees on a specific date."""
    return ["09:00", "14:00", "16:00"]


# ============================================================================
# Step 2: Create specialized sub-agents
# ============================================================================

calendar_agent = create_react_agent(
    ChatAnthropic(model="claude-3-5-sonnet-20241022"),
    tools=[create_calendar_event, get_available_time_slots],
    state_modifier=(
        "You are a calendar scheduling assistant. "
        "Parse natural language scheduling requests (e.g., 'next Tuesday at 2pm') "
        "into proper ISO datetime formats. "
        "Use get_available_time_slots to check availability when needed. "
        "Use create_calendar_event to schedule events. "
        "Always confirm what was scheduled in your final response."
    )
)

email_agent = create_react_agent(
    ChatAnthropic(model="claude-3-5-sonnet-20241022"),
    tools=[send_email],
    state_modifier=(
        "You are an email assistant. "
        "Compose professional emails based on natural language requests. "
        "Extract recipient information and craft appropriate subject lines and body text. "
        "Use send_email to send the message. "
        "Always confirm what was sent in your final response."
    )
)

# ============================================================================
# Step 3: Wrap sub-agents as tools for the supervisor
# ============================================================================

@tool(
    name="schedule_event",
    description=(
        "Schedule calendar events using natural language. "
        "Use this when the user wants to create, modify, or check calendar appointments. "
        "Handles date/time parsing, availability checking, and event creation. "
        "Input: Natural language scheduling request (e.g., 'meeting with design team next Tuesday at 2pm')"
    )
)
def schedule_event_tool(request: str) -> str:
    """Schedule a calendar event using natural language."""
    result = calendar_agent.invoke({
        "messages": [{"role": "user", "content": request}]
    })
    return result["messages"][-1].content


@tool(
    name="manage_email",
    description=(
        "Send emails using natural language. "
        "Use this when the user wants to send notifications, reminders, or any email communication. "
        "Handles recipient extraction, subject generation, and email composition. "
        "Input: Natural language email request (e.g., 'send them a reminder about the meeting')"
    )
)
def manage_email_tool(request: str) -> str:
    """Send or draft an email using natural language."""
    result = email_agent.invoke({
        "messages": [{"role": "user", "content": request}]
    })
    return result["messages"][-1].content


# ============================================================================
# Step 4: Create the supervisor agent
# ============================================================================

supervisor_agent = create_react_agent(
    ChatAnthropic(model="claude-3-5-sonnet-20241022"),
    tools=[schedule_event_tool, manage_email_tool],
    state_modifier=(
        "You are a helpful personal assistant. "
        "You can schedule calendar events and send emails. "
        "Break down user requests into appropriate tool calls and coordinate the results. "
        "When a request involves multiple actions, use multiple tools in sequence."
    )
)

# ============================================================================
# Step 5: Use the supervisor
# ============================================================================

if __name__ == "__main__":
    # Example: User request requiring both calendar and email coordination
    user_request = (
        "Schedule a meeting with the design team next Tuesday at 2pm for 1 hour, "
        "and send them an email reminder about reviewing the new mockups."
    )

    print("User Request:", user_request)
    print("\n" + "="*80 + "\n")

    result = supervisor_agent.invoke({
        "messages": [{"role": "user", "content": user_request}]
    })

    print("Supervisor Response:")
    print(result["messages"][-1].content)
```

</Expandable>

## Understanding the architecture

Your system has three layers. The bottom layer contains rigid API tools that require exact formats. The middle layer contains sub-agents that accept natural language, translate it to structured API calls, and return natural language confirmations. The top layer contains the supervisor that routes to high-level capabilities and synthesizes results.

This separation of concerns provides several benefits: each layer has a focused responsibility, you can add new domains without affecting existing ones, you can test each layer independently, complexity grows linearly rather than exponentially, and specialized agents perform better than generalists.

## Advanced: Control information flow

By default, sub-agents receive only the request string from the supervisor. You might want to pass additional context, such as conversation history or user preferences.

### Pass full conversation history to sub-agents

```python
from typing import Annotated
from langgraph.prebuilt import InjectedState

@tool(
    name="schedule_event",
    description="Schedule calendar events using natural language."
)
def schedule_event_tool(
    request: str,
    state: Annotated[dict, InjectedState]
) -> str:
    """Schedule a calendar event with access to full conversation history."""
    # Pass conversation history to sub-agent for context
    result = calendar_agent.invoke({
        "messages": state["messages"],
    })
    return result["messages"][-1].content
```

This allows sub-agents to see the full conversation context, which can be useful for resolving ambiguities like "schedule it for the same time tomorrow" (referencing a previous conversation).

### Control what supervisor receives

You can also customize what information flows back to the supervisor:

```python
import json

@tool(name="schedule_event")
def schedule_event_tool(request: str) -> str:
    result = calendar_agent.invoke({
        "messages": [{"role": "user", "content": request}]
    })

    # Option 1: Return just the confirmation message
    return result["messages"][-1].content

    # Option 2: Return structured data
    # return json.dumps({
    #     "status": "success",
    #     "event_id": "evt_123",
    #     "summary": result["messages"][-1].content
    # })
```

**Important:** Make sure sub-agent prompts emphasize that their final message should contain all relevant information. A common failure mode is sub-agents that perform tool calls but don't include the results in their final response.

## When to use the supervisor pattern

Use the supervisor pattern when you have multiple distinct domains (calendar, email, CRM, database), each domain has multiple tools or complex logic, you want centralized workflow control, and sub-agents don't need to converse directly with users.

For simpler cases with just a few tools, use a single agent. When agents need to have conversations with users, use [handoffs](/oss/python/langchain/multi-agent#handoffs) instead. For peer-to-peer collaboration between agents, consider other multi-agent patterns.

## Key takeaways

The supervisor pattern creates layers of abstraction where each layer has a clear responsibility. Specialized sub-agents outperform generalists, and complex systems emerge from composing simple, focused components.

When designing a supervisor system, start with clear domain boundaries and give each sub-agent focused tools and prompts. Write clear tool descriptions for the supervisor, test each layer independently before integration, and control information flow based on your specific needs.

## Next steps

Learn about [handoffs](/oss/python/langchain/multi-agent#handoffs) for agent-to-agent conversations, explore [context engineering](/oss/python/langchain/context-engineering) to fine-tune information flow, read the [multi-agent overview](/oss/python/langchain/multi-agent) to compare different patterns, and use [LangSmith](https://smith.langchain.com) to debug and monitor your multi-agent system.
